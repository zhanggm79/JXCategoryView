# 使用注意事项

## 个人主页效果

如果你对个人主页效果有疑问，或者想了解更多的个人主页效果，请到这个库[JXPagingView 点击参看](https://github.com/pujiaxin33/JXPagingView)

## 侧滑手势处理

[侧滑手势处理文档地址](https://github.com/pujiaxin33/JXCategoryView/blob/master/Document/%E4%BE%A7%E6%BB%91%E6%89%8B%E5%8A%BF%E5%A4%84%E7%90%86.md)

## 左滑删除

因为列表容器可以左右滑动，如果要开启左滑删除，这个时候系统会响应列表容器的左右滑动，而不是列表cell的左滑删除。所以，建议的方案是禁止列表容器滑动，这样就可以响应列表的左滑删除了。
列表容器滑动禁止，使用下面的代码：
```Objective-C
self.listContainerView.scrollView.scrollEnabled = NO;
```

## `FDFullscreenPopGesture`等全屏手势处理

[`FDFullscreenPopGesture`等全屏手势处理文档地址](https://github.com/pujiaxin33/JXCategoryView/blob/master/Document/%E5%85%A8%E5%B1%8F%E6%89%8B%E5%8A%BF%E5%A4%84%E7%90%86.md)

## JXCategoryView状态刷新

初始化过后，有新的数据源、属性配置有变动时（比如从服务器拉取回来数据，重新赋值titles），需要调用`reloadData`方法刷新状态。

## defaultSelectedIndex使用

用于配置默认展示列表的index，比如默认想要展示第三个列表，在初始化的时候添加下面代码：
```Objective-C
self.categoryView.defaultSelectedIndex = 2;
self.listContainerView.defaultSelectedIndex = 2;
```

## contentScrollView关联说明

JXCategoryView没有与contentScrollView强关联，你甚至可以不设置这个属性，把它当做简单的SegmentedControl。他们之间布局没有任何要求，可以把JXCategoryView放入导航栏、UITableViewSectionHeader等任何你想要的地方。

## 点击Item之后contentScrollView切换效果

系统内部通过代码`[self.contentScrollView setContentOffset:CGPointMake(targetIndex*self.contentScrollView.bounds.size.width, 0) animated:self.isContentScrollViewClickTransitionAnimationEnabled];`实现切换。

设置`contentScrollViewClickTransitionAnimationEnabled`属性即可控制是否`animated`

## 列表cell点击跳转示例

Demo的使用方法是给列表新增一个属性：`@property (nonatomic, strong) UINavigationController *naviController`，然后将父VC的navigationController赋值给它。这样列表的cell点击就可以通过自定义的`naviController`属性进行跳转了。详情参考源码[LoadDataListBaseViewController](https://github.com/pujiaxin33/JXCategoryView/blob/master/JXCategoryView/Example/LoadData/LoadDataListBaseViewController.h)

## 列表调用`presentViewController`方法

参考上面【列表cell点击跳转示例】示例，传递`UINavigationController`给列表的`naviController`属性，然后用`naviController`调用`presentViewController`。不能直接用列表来`presentViewController`

## 代码选中指定index

当业务需要某个时刻要跳转到指定index，比如当前index=0，用户点击了某个按钮，需要立即跳转到index=3的位置，使用下列代码即可：
```Objective-c
    [self.categoryView selectItemAtIndex:3];
    [self.listContainerView didClickSelectedItemAtIndex:3];
```

## JXCategoryView.collectionView高度取整说明

高度取整代码：
```Objective-c
- (void)layoutSubviews {
    [super layoutSubviews];

    self.collectionView.frame = CGRectMake(0, 0, self.bounds.size.width, floor(self.bounds.size.height));
}
```
部分使用者为了适配不同的手机屏幕尺寸，JXCategoryView的宽高比要求保持一样。所以它的高度就会因为不同宽度的屏幕而不一样。计算出来的高度，有时候会是位数很长的浮点数，如果把这个高度设置给UICollectionView就会触发内部的一个错误。所以，为了规避这个问题，在这里对高度统一向下取整。
如果向下取整导致了你的页面异常，请自己重新设置JXCategoryView的高度，保证为整数即可。

## 对父VC的automaticallyAdjustsScrollViewInsets属性设置为NO

因为JXCategoryView内部使用了UICollectionView，在某些系统会对内部的UICollectionView进行错误的调整。所以，内部会自己找到父VC，然后将其automaticallyAdjustsScrollViewInsets属性设置为NO。
```Objective-c
- (void)willMoveToSuperview:(UIView *)newSuperview {
    [super willMoveToSuperview:newSuperview];

    UIResponder *next = newSuperview;
    while (next != nil) {
        if ([next isKindOfClass:[UIViewController class]]) {
            ((UIViewController *)next).automaticallyAdjustsScrollViewInsets = NO;
            break;
        }
        next = next.nextResponder;
    }
}
```

## 使用多行文本

通过设置`JXCategoryTitleView`的`titleNumberOfLines`属性为指定行数，比如2就是显示两行。但是因为内部实现原理限制，目前暂不支持自动换行，需要自己插入\n换行符。详情请参考【多行文本】使用示例。

## iPhoneX刘海屏手机列表底部安全距离显示建议

1、使用`JXCategoryListCollectionContainerView`类不会有底部安全边距问题；
2、列表使用`UIView`封装不会有底部安全边距问题；
3、列表使用`UIViewController`封装有底部安全边距问题，添加代码` [self addChildViewController:listVC];`即可避免，完整代码如下：
```Objective-C
- (id<JXCategoryListContentViewDelegate>)listContainerView:(JXCategoryListContainerView *)listContainerView initListForIndex:(NSInteger)index {
    LoadDataListContainerListViewController *listVC = [[LoadDataListContainerListViewController alloc] init];
    listVC.naviController = self.navigationController;
    //如果列表是UIViewController包裹的，需要添加addChildViewController代码，这样子在iPhoneX系列手机就不会有底部安全距离错误的问题！！！
    [self addChildViewController:listVC];
    return listVC;
}
```

## 列表容器禁止左右滑动

添加如下代码即可：
```Objective-C
self.listContainerView.scrollView.scrollEnabled = NO;
```
 
## 单个cell刷新 

调用`- (void)reloadCellAtIndex:(NSInteger)index;`方法刷新指定index。
某些情况需要刷新某一个cell的UI显示，比如红点示例里面。

## 点击item时指示器和列表滚动时效果一致

目前指示器的过渡效果分为：跟随列表滚动、点击item过渡两种。它们分开处理，如果你希望点击item时和跟随列表滚动效果一致，请参考如下代码：
```Objective-C
indicatorLineView.scrollStyle = JXCategoryIndicatorScrollStyleSameAsUserScroll;
```
目前仅支持`JXCategoryIndicatorLineView`、`JXCategoryIndicatorDotLineView`类。如果是自定义的指示器请参考它们的处理方式支持该效果，其实就是通过动画的方式模拟跟随列表滚动的效果。

## 当列表是UIViewController类时，为什么不要依赖于UIViewController的生命周期方法?

首先如果依赖于UIViewController的生命周期方法，列表反复的左右切换，系统就无法正确触发列表VC的生命周期方法。因为这个时候，比如从A切换到B，是业务逻辑上面的A消失了，B显示了。系统并不知道这一情况。所以，如果要依赖UIViewController的生命周期方法，需要我们自己去触发。需要用到以下API:
```Objective-C
// If a custom container controller manually forwards its appearance callbacks, then rather than calling
// viewWillAppear:, viewDidAppear: viewWillDisappear:, or viewDidDisappear: on the children these methods
// should be used instead. This will ensure that descendent child controllers appearance methods will be
// invoked. It also enables more complex custom transitions to be implemented since the appearance callbacks are
// now tied to the final matching invocation of endAppearanceTransition.
- (void)beginAppearanceTransition:(BOOL)isAppearing animated:(BOOL)animated __OSX_AVAILABLE_STARTING(__MAC_NA,__IPHONE_5_0);
- (void)endAppearanceTransition __OSX_AVAILABLE_STARTING(__MAC_NA,__IPHONE_5_0);
```

`beginAppearanceTransition`和`endAppearanceTransition`方法必须成对出现。
比如要触发`viewWillAppear`和`viewDidAppear`
```
[listVC beginAppearanceTransition:YES animated:NO];
[listVC endAppearanceTransition];
```

比如要触发`viewWillDisappear`和`viewDidDisappear`
```
[listVC beginAppearanceTransition:NO animated:NO];
[listVC endAppearanceTransition];
```

如果我们的逻辑是这样的：用户从A滑动到B的时候，滑动了一点，就调用`[listVCB beginAppearanceTransition:YES animated:NO];`触发B列表的`viewWillAppear`方法，然后等B完全占满整个屏幕的时候调用`[listVCB endAppearanceTransition]`触发B列表的`viewDidAppear`方法。从这个正常流程来说，一切都是合理的。但是，如果当用户A滑动B的过程中取消了，然后又回弹到A。这种情况，就会触发B的`viewWillAppear`，就不会触发`viewDidAppear`方法了。

等于说，这种情况下列表的`viewWillAppear`和`viewDidAppear`不会两个都触发。就会造成逻辑问题。然后，我们再来回顾一下系统触发这两个API的流程，当push一个新页面的时候，系统会先触发``viewWillAppear`方法，让我们在真正显示之前可以处理一些逻辑。然后等页面真正显示的时候，再触发`viewDidAppear`让我们根据情况再调整。对于系统来说，`viewWillAppear`和`viewDidAppear`绝对会成对出现的，不可能只有`viewWillAppear`没有`viewDidAppear`。基于此，我们能做到的就是，当列表B刚显示一点的时候，就直接成对的触发`viewWillAppear`和`viewDidAppear`方法，而不是等到B完全显示的时候，再触发`viewDidAppear`。但是这样做的结果，就是`viewWillAppear`和`viewDidAppear`它们俩就只是一个生命周期方法了，will和did之间没有区别了。

所以，基于我把列表抽象为遵从`JXCategoryListContentViewDelegate`协议的类，并不指定为`UIViewController`，这样再强行依赖于`viewWillAppear`、`viewDidAppear`等生命周期方法，已经没有意义。所以，对于业务上面，要监听列表显示事件的，请实现协议方法`- (void)listDidAppear`。

 
## 自定义建议

`JXCategoryView`即使提供了灵活扩展，也不可能满足所有情况。未能满足特殊需求的情况，建议通过fork仓库，实现特殊效果。
